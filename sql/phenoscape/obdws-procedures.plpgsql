CREATE OR REPLACE FUNCTION populate_phenotype_inheres_in_part_of_entity() RETURNS VOID 
AS
$$
DECLARE 

BEGIN 
INSERT INTO phenotype_inheres_in_part_of_entity 
(
phenotype_nid, 
entity_nid, 
entity_uid, 
entity_label
)
SELECT DISTINCT 
phenotype_node.node_id AS phenotype_nid,
entity_node.node_id AS entity_nid, 
entity_node.uid AS entity_uid, 
entity_node.label AS entity
FROM 
node AS phenotype_node 
JOIN (link 
JOIN node AS entity_node 
ON (entity_node.node_id = link.object_id)) 
ON (phenotype_node.node_id = link.node_id) 
WHERE 
link.predicate_id = (SELECT node_id FROM node WHERE uid = 'OBO_REL:inheres_in_part_of');
END
$$LANGUAGE 'plpgsql'; 

CREATE OR REPLACE FUNCTION populate_metadata_table() RETURNS VOID
AS
$$
DECLARE 

BEGIN 
INSERT INTO taxon_phenotype_metadata  
(
reif_id, 
phenotype_uid, 
taxon_uid, taxon_label, 
entity_uid, entity_label, 
quality_uid, quality_label, 
publication, 
character_text, character_comment, character_number, 
state_text, state_comment, 
curators
)
SELECT
exhibits_link.reiflink_node_id, 
phenotype_node.uid AS phenotype,
taxon_node.uid AS taxon_id, 
taxon_node.label AS taxon, 
entity_node.uid AS entity_id, 
entity_node.label AS entity, 
quality_node.uid AS quality_id, 
quality_node.label AS quality, 
pub_node.uid AS publication,
character_node.label AS character_text,
char_tag.val AS char_comment, 
char_num_tag.val AS char_number, 
state_node.label AS state_text, 
state_tag.val AS state_comment, 
curator_tag.val AS curators
FROM 
link AS exhibits_link 
JOIN link AS posited_by_link ON (posited_by_link.node_id = exhibits_link.reiflink_node_id AND 
	posited_by_link.predicate_id = (SELECT node_id FROM node WHERE uid='posited_by'))
JOIN (link AS has_pub_link 
JOIN node AS pub_node 
ON (has_pub_link.object_id = pub_node.node_id AND 
	has_pub_link.predicate_id = (SELECT node_id FROM node WHERE uid='PHENOSCAPE:has_publication'))) 
ON (posited_by_link.object_id = has_pub_link.node_id) 
JOIN (link AS has_state_link 
JOIN (link AS has_state_link2 
JOIN (node AS state_node 
JOIN (link AS has_character_link 
JOIN node AS character_node 
ON (has_character_link.node_id = character_node.node_id AND 
	has_character_link.predicate_id = (SELECT node_id FROM node WHERE uid='cdao:has_Datum')))
ON (has_character_link.object_id = state_node.node_id)) 
ON (has_state_link2.object_id = state_node.node_id AND 
	has_state_link2.predicate_id = (SELECT node_id FROM node WHERE uid='cdao:has_State')))
ON (has_state_link2.node_id = has_state_link.object_id AND 
	has_state_link.predicate_id = (SELECT node_id FROM node WHERE uid='cdao:has_State'))) 
ON (has_state_link.node_id =  exhibits_link.reiflink_node_id)
JOIN node AS taxon_node ON (exhibits_link.node_id = taxon_node.node_id) 
JOIN node AS phenotype_node ON (exhibits_link.object_id = phenotype_node.node_id)
JOIN (link AS inheres_in_link 
JOIN node AS entity_node 
ON (inheres_in_link.object_id = entity_node.node_id AND 
	inheres_in_link.predicate_id = (SELECT node_id FROM node WHERE uid='OBO_REL:inheres_in'))) 
ON (inheres_in_link.node_id = phenotype_node.node_id) 
JOIN (link AS is_a_link 
JOIN node AS quality_node 
ON (is_a_link.object_id = quality_node.node_id AND 
	is_a_link.predicate_id = (SELECT node_id FROM node WHERE uid='OBO_REL:is_a'))) 
ON (is_a_link.node_id = phenotype_node.node_id) 
JOIN tagval AS curator_tag ON ((curator_tag.node_id = posited_by_link.object_id) 
	AND (curator_tag.tag_id = (SELECT node_id FROM node WHERE uid = 'PHENOSCAPE:has_curators')))
JOIN tagval AS char_tag ON ((char_tag.node_id = character_node.node_id) 
	AND (char_tag.tag_id = (SELECT node_id FROM node WHERE uid = 'PHENOSCAPE:has_comment')))	
JOIN tagval AS state_tag ON ((state_tag.node_id = state_node.node_id) 
	AND (state_tag.tag_id = (SELECT node_id FROM node WHERE uid = 'PHENOSCAPE:has_comment')))
JOIN tagval AS char_num_tag ON ((char_num_tag.node_id = character_node.node_id) 
	AND (char_num_tag.tag_id = (SELECT node_id FROM node WHERE uid = 'PHENOSCAPE:has_number')))
WHERE 
exhibits_link.is_inferred = 'f' AND 
inheres_in_link.is_inferred = 'f' AND 
is_a_link.is_inferred = 'f';
END
$$LANGUAGE 'plpgsql'; 


CREATE OR REPLACE FUNCTION populate_phenotype_table() RETURNS VOID 
AS
$$
DECLARE 
	
BEGIN
INSERT INTO phenotype_by_entity_character  
(
phenotype_nid, phenotype_uid, 
subject_nid, subject_uid, subject_label, 
gene_or_taxon, 
quality_nid, quality_uid, quality_label, 
character_nid, character_uid, character_label, 
count, 
entity_nid, entity_uid, entity_label, 
related_entity_nid, related_entity_uid, related_entity_label, 
reif_id
) 
SELECT DISTINCT 
phenotype_node.node_id AS phenotype_nid, 
phenotype_node.uid AS phenotype, 
CASE WHEN gene_node.node_id IS NULL THEN taxon_node.node_id ELSE gene_node.node_id END AS subject_nid, 
CASE WHEN gene_node.uid IS NULL THEN taxon_node.uid ELSE gene_node.uid END AS subject_uid, 
CASE WHEN gene_node.label IS NULL THEN taxon_node.label ELSE gene_node.label END AS subject_label, 
CASE WHEN gene_node.uid IS NULL THEN 'T' ELSE 'G' END AS gene_or_taxon, 
quality_node.node_id AS quality_nid, 
quality_node.uid AS quality_uid,
quality_node.label AS quality_label, 
character_node.node_id AS character_nid, 
character_node.uid AS character_uid,
character_node.label AS character_label, 
count_node.uid AS count, 
entity_node.node_id AS entity_nid, 
entity_node.uid AS entity_uid,
entity_node.label AS entity_label, 
related_entity_node.node_id AS related_entity_nid,
related_entity_node.uid AS related_entity_uid, 
related_entity_node.label AS related_entity_label,
exhibits_link.reiflink_node_id AS reif_id
FROM 
node AS phenotype_node 
JOIN (link AS exhibits_link 
JOIN (node AS taxon_node 
LEFT OUTER JOIN (link AS has_allele_link 
JOIN node AS gene_node 
ON (has_allele_link.node_id = gene_node.node_id AND 
	has_allele_link.predicate_id = (SELECT node_id FROM node WHERE uid = 'PHENOSCAPE:has_allele'))) 
ON (taxon_node.node_id = has_allele_link.object_id)) 
ON (exhibits_link.node_id = taxon_node.node_id AND 
	exhibits_link.predicate_id = (SELECT node_id FROM node WHERE uid = 'PHENOSCAPE:exhibits'))) 
ON (exhibits_link.object_id = phenotype_node.node_id) 
JOIN (link AS is_a_link 
JOIN (node AS quality_node 
JOIN (link AS value_for_link 
JOIN node AS character_node 
ON (value_for_link.object_id = character_node.node_id AND 
	value_for_link.predicate_id = (SELECT node_id FROM node WHERE uid = 'PHENOSCAPE:value_for'))) 
ON (quality_node.node_id = value_for_link.node_id )) 
ON (is_a_link.object_id = quality_node.node_id AND 
	is_a_link.predicate_id = (SELECT node_id FROM node WHERE uid = 'OBO_REL:is_a')))
ON (phenotype_node.node_id = is_a_link.node_id) 	
JOIN (link AS inheres_in_link 
JOIN node AS entity_node 
ON (entity_node.node_id = inheres_in_link.object_id AND 
	inheres_in_link.predicate_id = (SELECT node_id FROM node WHERE uid = 'OBO_REL:inheres_in'))) 
ON (inheres_in_link.node_id = phenotype_node.node_id) 
LEFT OUTER JOIN (link AS has_count_link 
JOIN node AS count_node 
ON (has_count_link.object_id = count_node.node_id AND 
	has_count_link.predicate_id = (SELECT node_id FROM node WHERE uid = 'PHENOSCAPE:has_count'))) 
ON (phenotype_node.node_id = has_count_link.node_id) 
LEFT OUTER JOIN (link AS towards_link 
JOIN node AS related_entity_node 
ON (towards_link.object_id = related_entity_node.node_id AND 
	towards_link.predicate_id = (SELECT node_id FROM node WHERE uid = 'OBO_REL:towards'))) 
ON (phenotype_node.node_id = towards_link.node_id)	
WHERE
exhibits_link.is_inferred = 'f' AND 
is_a_link.is_inferred = 'f' AND 
inheres_in_link.is_inferred = 'f'; 
END
$$LANGUAGE 'plpgsql'; 

CREATE TABLE anatomyrow (search_id VARCHAR, phenotype_id INT, phenotype_label VARCHAR, entity_info VARCHAR, quality_info VARCHAR, 
attribute_info VARCHAR, taxa_info VARCHAR);

CREATE OR REPLACE FUNCTION getAnatomyInfo(VARCHAR) RETURNS SETOF anatomyrow AS 
$$
DECLARE 
	result anatomyrow%rowtype;
	qualityRecord RECORD;
	phenotype INT;
	quality VARCHAR;
	entity VARCHAR;
	taxa VARCHAR;
	gene VARCHAR;
	attribute VARCHAR;
	qualityAndAttribute VARCHAR[2];
BEGIN	
FOR result IN 
SELECT DISTINCT 
$1 AS search_id, phenotype_node.node_id as phenotype_id, phenotype_node.uid AS phenotype_label, 'entity' AS entity_info, 'quality' AS quality_info, 
'attribute' AS attribute_info, 'taxa' AS taxa_info
FROM 
node AS taxon_node INNER JOIN link AS exhibits_link INNER JOIN
node AS phenotype_node INNER JOIN link AS inheres_in_link INNER JOIN node AS search_node ON (inheres_in_link.object_id = search_node.node_id)
ON (phenotype_node.node_id = inheres_in_link.node_id) ON (exhibits_link.object_id = phenotype_node.node_id) ON (taxon_node.node_id = exhibits_link.node_id), 
node AS inheres_in_pred_node, node AS exhibits_pred_node
WHERE
search_node.uid = $1 AND
exhibits_pred_node.uid = 'PHENOSCAPE:exhibits' AND
inheres_in_pred_node.uid = 'OBO_REL:inheres_in' AND
exhibits_link.predicate_id = exhibits_pred_node.node_id AND
inheres_in_link.predicate_id = inheres_in_pred_node.node_id 
LOOP
	phenotype := result.phenotype_id;
	qualityRecord := getQualityFromPhenotype(phenotype);
	attribute := readCharacterForState(qualityRecord.quality_id);
	quality := qualityRecord.quality;
	taxa := getTaxaForPhenotype(phenotype);
	entity := getEntityFromPhenotype(phenotype);
	result.search_id := $1;	
	result.entity_info := entity;
	result.quality_info := quality;
	result.attribute_info := attribute;
	result.taxa_info := taxa;
	RETURN NEXT result;
END LOOP;
--RAISE NOTICE '% unique phenotypes found', count;
END
$$ LANGUAGE 'plpgsql';

CREATE or REPLACE FUNCTION getQualityFromPhenotype(INT) RETURNS RECORD AS
$$
SELECT object_id AS quality_id, node_uid(object_id) || ' (' || node_label(object_id) || ')' AS quality FROM link 
WHERE predicate_id = (SELECT node_id FROM node WHERE uid = 'OBO_REL:is_a')
AND node_id = $1 AND is_inferred = 'f';
$$ LANGUAGE 'sql';

CREATE OR REPLACE FUNCTION getEntityFromPhenotype(INT) RETURNS VARCHAR AS
$$
DECLARE 
entity_id VARCHAR;
BEGIN
SELECT node_uid(object_id) || ' ' || node_label(object_id) INTO entity_id FROM link WHERE
predicate_id = (SELECT node_id FROM node WHERE uid = 'OBO_REL:inheres_in') AND node_id = $1
AND is_inferred = 'f';
RETURN entity_id;
END;
$$ LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION getTaxaForPhenotype(INT) RETURNS VARCHAR[]
AS
$$
DECLARE
rec RECORD;
gene RECORD;
taxa VARCHAR[20];
ct int := 0;
BEGIN
FOR rec IN
SELECT node_id, node_uid(node_id) AS uid, node_label(node_id) AS label FROM link WHERE
predicate_id = (SELECT node_id FROM node WHERE uid = 'PHENOSCAPE:exhibits')
AND object_id = $1
LOOP
ct := ct + 1;
taxa[ct] := rec.uid || '(' || rec.label || ')';
IF (rec.uid NOT LIKE '%TTO%') THEN
FOR gene IN
SELECT node_uid(node_id) AS gId, node_label(node_id) AS gLabel FROM link WHERE
predicate_id = (SELECT node_id FROM node WHERE uid = 'PHENOSCAPE:has_allele')
AND object_id = rec.node_id
LOOP
taxa[ct] := gene.gId || '(' || gene.gLabel || ')';
END LOOP;
END IF;
END LOOP;
RETURN taxa;	
END
$$ LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION readCharacterForState(INT) RETURNS VARCHAR
AS
$$
SELECT getAttributeForQuality FROM patoStateToCharacterMap WHERE
node_id = $1;
$$ LANGUAGE 'sql';

CREATE OR REPLACE FUNCTION createStateToCharacterMapping() RETURNS void AS
$$
BEGIN	
EXECUTE 'CREATE OR REPLACE VIEW patoStateToCharacterMap AS 
SELECT node_id, uid, label, getAttributeForQuality(node_id) FROM node WHERE source_id = (SELECT node_id FROM node WHERE uid = ''quality'')';
RETURN;
END
$$ LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION getAttributeForQuality(INT) RETURNS INTEGER
AS
$$
DECLARE
res 		VARCHAR;
attr_id 	INT;
slim    	VARCHAR;
slim_id 	INT;
temp_id 	INT;
super_id 	INT;
root_id  INT;
BEGIN
SELECT DISTINCT object_id, node_uid(object_id) INTO slim_id, slim FROM link
WHERE node_id = $1 AND predicate_id = (SELECT node_id FROM node WHERE uid = 'oboInOwl:inSubset')
AND object_id IN (SELECT node_id FROM node WHERE uid IN ('value_slim', 'attribute_slim'));
IF (slim IS NULL) THEN
	SELECT object_id FROM link INTO super_id WHERE node_id = $1 AND predicate_id = (SELECT node_id FROM node WHERE uid = 'OBO_REL:is_a') AND is_inferred = 'f';
	IF (super_id IS NULL) THEN
		SELECT DISTINCT node_id FROM link INTO temp_id WHERE object_id = $1 AND predicate_id = (SELECT node_id FROM node WHERE uid = 'oboInOwl:hasDbXref');
		IF temp_id IS NULL THEN
			SELECT node_id FROM node INTO root_id WHERE uid = 'PATO:0000001';
			RETURN root_id;  
		ELSE
			RETURN getAttributeForQuality(temp_id);
		END IF;
	ELSE
		RETURN getAttributeForQuality(super_id);
	END IF;	
ELSIF (slim = 'attribute_slim') THEN
RETURN $1; 
ELSE
SELECT object_id INTO attr_id FROM link
WHERE node_id = $1 AND 
predicate_id = (SELECT node_id FROM node WHERE uid = 'OBO_REL:is_a') AND
is_inferred = 'f';
RETURN getAttributeForQuality(attr_id);
END IF;
END
$$ LANGUAGE 'plpgsql';

/*
This is a function that uses materialized views to retrieve information about an anatomical entity,
in the same manner as the original 'getanatomyinfo' method
*/

CREATE OR REPLACE FUNCTION getAnatomyInfoFromMatViews(VARCHAR) RETURNS SETOF anatomyrow
AS
$$
DECLARE
result     	   anatomyrow%rowtype;
search_id  	   INT;
phenotype_id   INT;
taxa		   VARCHAR[2];	
taxaRec		   RECORD;
phenRec  	   RECORD;
count		   INT;	 
gene	   	   VARCHAR;  
qId			   INT;
BEGIN
SELECT node_id INTO search_id FROM node WHERE uid = $1; 
PERFORM realize_relation('OBO_REL:inheres_in');
PERFORM realize_relation('PHENOSCAPE:exhibits');
PERFORM realize_relation('OBO_REL:is_a');
PERFORM realize_relation('PHENOSCAPE:has_allele');
FOR phenRec IN
SELECT * FROM OBO_REL.inheres_in WHERE object_id = search_id
LOOP
count := 0;
taxa := NULL;
result.search_id := $1; 
result.phenotype_id := phenRec.node_id;
result.phenotype_label := node_uid(phenRec.node_id); 
SELECT node_uid(object_id) || '(' || node_label(object_id) || ')' INTO result.entity_info FROM asserted_OBO_REL.inheres_in WHERE node_id = phenRec.node_id;
SELECT node_uid(object_id) || '(' || node_label(object_id) || ')', object_id INTO result.quality_info, qId FROM asserted_OBO_REL.is_a WHERE node_id = phenRec.node_id;
result.attribute_info := readCharacterForState(qId);
FOR taxaRec IN
SELECT node_id AS TorGid, node_uid(node_id) AS TorG FROM asserted_PHENOSCAPE.exhibits WHERE object_id = phenRec.node_id
LOOP
count := count + 1;
IF (taxaRec.TorG LIKE '%TTO%') THEN
	taxa[count] := taxaRec.TorG;
ELSE
	SELECT node_uid(node_id) INTO gene FROM asserted_PHENOSCAPE.has_allele WHERE object_id = taxaRec.TorGid;
	taxa[count] := gene; 
END IF;
END LOOP;
-- RAISE NOTICE 'Taxa: %', taxa;
result.taxa_info := taxa;
RETURN NEXT result;
END LOOP;
END
$$
LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION get_equivalent_tao_term_for_zfa_entity(INT) RETURNS INTEGER
AS
$$
DECLARE
tao_id        INT;
interim_id    INT;
BEGIN
SELECT object_id INTO tao_id FROM link WHERE predicate_id = (SELECT node_id FROM node WHERE uid = 'OBO_REL:is_a') AND 
node_id = $1 AND node_uid(object_id) LIKE 'TAO:%' AND
is_inferred = 'f';
IF tao_id IS NULL THEN
SELECT object_id INTO interim_id FROM link WHERE predicate_id = (SELECT node_id FROM node WHERE uid = 'OBO_REL:is_a') AND
node_id = $1; 
  IF interim_id IS NULL THEN
  		RETURN NULL;
  ELSE
  		RETURN get_equivalent_tao_term_for_zfa_entity(interim_id);
  END IF;				
ELSE
RETURN tao_id;
END IF;
END
$$
LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION replace_zfa_term_with_tao_term () RETURNS VOID
AS
$$
DECLARE
lin_id   INT;
tao_id   INT;
obj_id   INT;
rec      RECORD;
BEGIN
FOR rec IN 
SELECT link_id, object_id FROM link WHERE 
predicate_id = (SELECT node_id FROM node WHERE uid = 'OBO_REL:inheres_in') AND
is_inferred = 'f' AND
object_id IN (SELECT node_id FROM node WHERE uid LIKE 'ZFA:%')
LOOP
obj_id := rec.object_id;
lin_id := rec.link_id;
IF (get_equivalent_tao_term_for_zfa_entity(obj_id) IS NOT NULL) THEN
tao_id := get_equivalent_tao_term_for_zfa_entity(obj_id);
EXECUTE 'UPDATE link SET object_id = '|| tao_id ||' WHERE link_id = ' || lin_id || '';
--RAISE NOTICE 'CHANGING % TO %', obj_id, tao_id;
--ELSE
--EXECUTE 'DELETE FROM link WHERE link_id = ' || lin_id || '';
--RAISE NOTICE 'DELETING row';
END IF;
END LOOP;
END
$$
LANGUAGE 'plpgsql';