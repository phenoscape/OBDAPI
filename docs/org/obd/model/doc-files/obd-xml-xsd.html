<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title></title>
<style>
          body { background: white;
                 color: black; }
          h2   { border-top: black solid 1px;
                 margin-top: 2em;
                 padding-top: 1em; }
        </style>
</head>
<body>
<h2>Table of Contents</h2>
<h3>Elements</h3>
<ul>
<li><a href="#element-type-CompositionalDescription">CompositionalDescription</a></li>
<li><a href="#element-type-Graph">Graph</a></li>
<li><a href="#element-type-InstanceQuantifier">InstanceQuantifier</a></li>
<li><a href="#element-type-LinkStatement">LinkStatement</a></li>
<li><a href="#element-type-Node">Node</a></li>
<li><a href="#element-type-Nodes">Nodes</a></li>
<li><a href="#element-type-Statements">Statements</a></li>
<li><a href="#element-type-compositionalDescription">compositionalDescription</a></li>
<li><a href="#element-type-context">context</a></li>
<li><a href="#element-type-node">node</a></li>
<li><a href="#element-type-positedBy">positedBy</a></li>
<li><a href="#element-type-relation">relation</a></li>
<li><a href="#element-type-restriction">restriction</a></li>
<li><a href="#element-type-source">source</a></li>
<li><a href="#element-type-target">target</a></li>
<li><a href="#element-type-value">value</a></li>
</ul>
<h3>Content Model Groups</h3>
<ul>
<li><a href="#group-LiteralStatement">LiteralStatement</a></li>
<li><a href="#group-Statement">Statement</a></li>
<li><a href="#group-Statement_Attrs">Statement_Attrs</a></li>
<li><a href="#group-Statement_Elts">Statement_Elts</a></li>
<li><a href="#group-UnaryPropertyStatement">UnaryPropertyStatement</a></li>
</ul>
  <h2 id="element-type-Graph">Element Type: Graph</h2>
      <p>A graph is simply a holder for Nodes and Statements.
Nodes represent instances, types or relations, and the
edges of the graph are statements concerning these Nodes.

Statement elements can be nested under the Graph element
or under a Node element. Semantically there is no difference
between these alternate structures.</p>
    <h3>Content Model</h3>
      <p>Optional repeatable choice of:</p>
<ul>
        <li>Exactly 1 <a href="#element-type-Node">Node</a>
</li>
        <li>Exactly 1 <a href="#group-Statement">Statement</a> group</li>
      </ul>
    
  <h2 id="element-type-Nodes">Element Type: Nodes</h2>
<h3>Content Model</h3>
      <p>Exactly 1 sequences of:</p>
<ol>
        <li>Optional repeatable <a href="#element-type-Node">Node</a>
</li>
      </ol>
    
  <h2 id="element-type-Statements">Element Type: Statements</h2>
<h3>Content Model</h3>
      <ul><li>Optional repeatable <a href="#group-Statement">Statement</a> group</li></ul>
    
  <h2 id="group-Statement">Content Model Group: Statement</h2>
<h3>Content Particle</h3>
<p>Exactly 1 choice of:</p>
<ul>
      <li>Exactly 1 <a href="#element-type-LinkStatement">LinkStatement</a>
</li>
      <li>Exactly 1 <a href="#group-LiteralStatement">LiteralStatement</a> group</li>
      <li>Exactly 1 <a href="#group-UnaryPropertyStatement">UnaryPropertyStatement</a> group</li>
    </ul>
  <h2 id="group-Statement_Attrs">Content Model Group: Statement_Attrs</h2>
      <p>A statement is some proposition, relation one or more entities via a predicate.
Examples: John loves Mary, all cell nucleus part_of cell, p53 participates_in DNA_Repair

Within the structure of the document, 
Statements can be nested beneath the nodes which they relate, or they can be nested 
underneath the Graph node. These are semantically identical. Clients may request one
form or another from servers in order to process them more easily.
For example: if a client requests all statements pertaining to the node for "holoprosencephaly",
the server may return these statements at the top level. However, all the nodes related to
holoprosencephaly node in this statement set may have additional metadata attached as LiteralStatements
at the node level

corresponds to an RDF triple, or in some cases, a bundle of triples
-- more accurately, corresponds to an OWL axiom, or fact</p>
    <h3>Content Particle</h3>
<p>Exactly 1 sequences of:</p>
<ol>
      <li>An optional <a href="#element-type-InstanceQuantifier">InstanceQuantifier</a>
</li>
    </ol>
  <h2 id="element-type-InstanceQuantifier">Element Type: InstanceQuantifier</h2>
      <p>applicable to class nodes only: determines how this statement relates instances
of this class</p>
    <table border="1">
<caption>Attributes</caption>
<tr valign="baseline">
<th align="left" rowspan="2">isExistential</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2">
          <p>if true, this link is treated as a
SubClassOf(Restriction(rel,someValuesFrom(target))) axiom</p>
        </td></tr>
<tr valign="baseline">
<th align="left" rowspan="2">isUniversal</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2">
          <p>if true, this link is treated as a
SubClassOf(Restriction(rel,allValuesFrom(target))) axiom</p>
        </td></tr>
<tr valign="baseline">
<th align="left" rowspan="2">minCardinality</th>
<td>Built-in type int</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2">
          <p>if set, this link is treated as a
SubClassOf(Restriction(rel,minCardinality(n,target))) axiom</p>
        </td></tr>
<tr valign="baseline">
<th align="left" rowspan="2">maxCardinality</th>
<td>Built-in type int</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2">
          <p>if set, this link is treated as a
SubClassOf(Restriction(rel,maxCardinality(n,target))) axiom</p>
        </td></tr>
</table>
<h3>Content Model</h3>
<p>Empty</p>
  
    
      <p>A statement is some proposition, relation one or more entities via a predicate.
Examples: John loves Mary, all cell nucleus part_of cell, p53 participates_in DNA_Repair

Within the structure of the document, 
Statements can be nested beneath the nodes which they relate, or they can be nested 
underneath the Graph node. These are semantically identical. Clients may request one
form or another from servers in order to process them more easily.
For example: if a client requests all statements pertaining to the node for "holoprosencephaly",
the server may return these statements at the top level. However, all the nodes related to
holoprosencephaly node in this statement set may have additional metadata attached as LiteralStatements
at the node level

corresponds to an RDF triple, or in some cases, a bundle of triples
-- more accurately, corresponds to an OWL axiom, or fact</p>
    
    
    
    
    
    
    
    
    
  
  <h2 id="group-Statement_Elts">Content Model Group: Statement_Elts</h2>
<h3>Content Particle</h3>
<p>Exactly 1 sequences of:</p>
<ol>
      <li>An optional <a href="#element-type-node">node</a>
</li>
      <li>Exactly 1 <a href="#element-type-relation">relation</a>
</li>
      <li>An optional <a href="#element-type-positedBy">positedBy</a>
</li>
      <li>An optional <a href="#element-type-source">source</a>
</li>
      <li>An optional <a href="#element-type-context">context</a>
</li>
      <li>Optional repeatable <a href="#group-Statement">Statement</a> group</li>
    </ol>
  <h2 id="element-type-node">Element Type: node</h2>
      <p>subject node, to which this statement applies</p>
    <h3>Content Model</h3>
<p>Simple type <a href="#simple-type-linkref">linkref</a></p>
  <h2 id="element-type-relation">Element Type: relation</h2>
      <p>predicate node: the relationship type</p>
    <h3>Content Model</h3>
<p>Simple type <a href="#simple-type-linkref">linkref</a></p>
  <h2 id="element-type-positedBy">Element Type: positedBy</h2>
      <p>for annotation statements: the annotation node that posits this statement
partially redundant with sub-statements, below</p>
    <h3>Content Model</h3>
<p>Simple type <a href="#simple-type-linkref">linkref</a></p>
  <h2 id="element-type-source">Element Type: source</h2>
      <p>where the statement comes from</p>
    <h3>Content Model</h3>
<p>Simple type <a href="#simple-type-linkref">linkref</a></p>
  <h2 id="element-type-context">Element Type: context</h2>
      <p>the statement applies when the node is in this context. TODO</p>
    <h3>Content Model</h3>
<p>Simple type <a href="#simple-type-linkref">linkref</a></p>
  <h2 id="element-type-LinkStatement">Element Type: LinkStatement</h2>
      <p>A statement connecting two nodes
Examples: p53 participates_in DNA_Repair</p>
    <table border="1">
<caption>Attributes</caption>
<tr valign="baseline">
<th align="left" rowspan="2">isEquivalentTo</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2">
          <p>true if the predicate is one of equivalence.
for class nodes, owl:equivalentClass
for relation nodes, owl:equivalentProperty</p>
        </td></tr>
<tr valign="baseline">
<th align="left" rowspan="2">isEquivalent</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2">
          <p>link provides an *equivalent class*, or a *class definition*</p>
        </td></tr>
<tr valign="baseline">
<th align="left" rowspan="2">isXref</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2"></td></tr>
<tr valign="baseline">
<th align="left" rowspan="2">isReflexive</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2">
          <p>true if the Node and Target are identical</p>
        </td></tr>
</table>
<h3>Content Model</h3>
      <p>Optional repeatable choice of:</p>
<ul>
        <li>Exactly 1 <a href="#group-Statement_Attrs">Statement_Attrs</a> group</li>
        <li>Exactly 1 choice of:<ul>
          <li>Exactly 1 <a href="#element-type-node">node</a>
</li>
          <li>Exactly 1 <a href="#element-type-relation">relation</a>
</li>
          <li>Exactly 1 <a href="#element-type-positedBy">positedBy</a>
</li>
          <li>Exactly 1 <a href="#element-type-source">source</a>
</li>
          <li>Exactly 1 <a href="#element-type-context">context</a>
</li>
          <li>Exactly 1 <a href="#group-Statement">Statement</a> group</li>
        </ul>
</li>
        <li>Exactly 1 <a href="#element-type-target">target</a>
</li>
      </ul>
      
      
      
      
      
    
  <h2 id="element-type-target">Element Type: target</h2>
      <p>the target node to which the node is being related to
Example: p53 participates_in DNA_Repair (DNA_Repair is target)</p>
    <h3>Content Model</h3>
<p>Simple type <a href="#simple-type-linkref">linkref</a></p>
  <h2 id="group-LiteralStatement">Content Model Group: LiteralStatement</h2>
<table border="1">
<caption>Attributes</caption>
<tr valign="baseline">
<th align="left" rowspan="2">isAlias</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2"></td></tr>
<tr valign="baseline">
<th align="left" rowspan="2">isTextDefinition</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2"></td></tr>
</table>
<h3>Content Particle</h3>
<p>Exactly 1 sequences of:</p>
<ol>
      <h2 id="element-type-LiteralStatement">Element Type: LiteralStatement</h2>
          <p>A statement relating a node to some DatatypeProperty
Examples: comments, descriptions, aliases.
for LiteralStatemens between an class node and a literal: SubClassOf(Restriction(pred,hasValue(VALUE))
for LiteralStatemens between an instance node and a literal: fact/triple</p>
        <table border="1">
<caption>Attributes</caption>
<tr valign="baseline">
<th align="left" rowspan="2">isAlias</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2"></td></tr>
<tr valign="baseline">
<th align="left" rowspan="2">isTextDefinition</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2"></td></tr>
</table>
<h3>Content Model</h3>
          <p>Optional repeatable choice of:</p>
<ul>
            <li>Exactly 1 <a href="#group-Statement_Attrs">Statement_Attrs</a> group</li>
            <li>Exactly 1 choice of:<ul>
              <li>Exactly 1 <a href="#element-type-node">node</a>
</li>
              <li>Exactly 1 <a href="#element-type-relation">relation</a>
</li>
              <li>Exactly 1 <a href="#element-type-positedBy">positedBy</a>
</li>
              <li>Exactly 1 <a href="#element-type-source">source</a>
</li>
              <li>Exactly 1 <a href="#element-type-context">context</a>
</li>
              <li>Exactly 1 <a href="#group-Statement">Statement</a> group</li>
            </ul>
</li>
            <li>Exactly 1 <a href="#element-type-value">value</a>
</li>
          </ul>
          
          
          
        
    </ol>
  <h2 id="element-type-value">Element Type: value</h2>
<h3>Content Model</h3>
<p>Simple type <a href="#simple-type-literal">literal</a></p>
  <h2 id="group-UnaryPropertyStatement">Content Model Group: UnaryPropertyStatement</h2>
<table border="1">
<caption>Attributes</caption>
<tr valign="baseline">
<th align="left" rowspan="2">isTransitive</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2"></td></tr>
</table>
<h3>Content Particle</h3>
<p>Exactly 1 sequences of:</p>
<ol>
      <h2 id="element-type-LiteralStatement">Element Type: LiteralStatement</h2>
          <p>A zero-argument about a node.
Example: Transitive(partOf)
Example: Transitive(partOf)
combine with isNegated to state that a property does not hold</p>
        <table border="1">
<caption>Attributes</caption>
<tr valign="baseline">
<th align="left" rowspan="2">isTransitive</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2"></td></tr>
</table>
<h3>Content Model</h3>
          <p>Optional repeatable choice of:</p>
<ul>
            <li>Exactly 1 <a href="#group-Statement_Attrs">Statement_Attrs</a> group</li>
            <li>Exactly 1 choice of:<ul>
              <li>Exactly 1 <a href="#element-type-node">node</a>
</li>
              <li>Exactly 1 <a href="#element-type-relation">relation</a>
</li>
              <li>Exactly 1 <a href="#element-type-positedBy">positedBy</a>
</li>
              <li>Exactly 1 <a href="#element-type-source">source</a>
</li>
              <li>Exactly 1 <a href="#element-type-context">context</a>
</li>
              <li>Exactly 1 <a href="#group-Statement">Statement</a> group</li>
            </ul>
</li>
          </ul>
          
          
        
    </ol>
  
    <p>Exactly 1 sequences of:</p>
<ol>
      <li>An optional <a href="#element-type-Node">Node</a>
</li>
    </ol>
    
  
  <h2 id="element-type-Node">Element Type: Node</h2>
      <p>equivalent to an RDF resource. can represent instances, relations/slots and universals</p>
    <table border="1">
<caption>Attributes</caption>
<tr valign="baseline">
<th align="left" rowspan="2">id</th>
<td>Simple type <a href="#simple-type-identifier_Type">identifier_Type</a>
</td>
<td>required</td>
</tr>
<tr valign="baseline"><td colspan="2">
          <p>A unique identifier for the Node. </p>
        </td></tr>
<tr valign="baseline">
<th align="left" rowspan="2">metatype</th>
<td>
          <p>Built-in type token</p>
<p>Enumeration:</p>
<ul>
<li><code>class</code></li>
<li><code>relation</code></li>
<li><code>instance</code></li>
</ul>
        </td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2">
          <p>Change to enum? </p>
        </td></tr>
<tr valign="baseline">
<th align="left" rowspan="2">isAnonymous</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2">
          <p>corresponds to rdf bNode</p>
        </td></tr>
<tr valign="baseline">
<th align="left" rowspan="2">isObsolete</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2">
          <p>true if the authority publishing this resource has retired the ID</p>
        </td></tr>
<tr valign="baseline">
<th align="left" rowspan="2">isTransitive</th>
<td>Built-in type boolean</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2">
          <p>relations only. corresponds to owl:TransitiveProperty</p>
        </td></tr>
</table>
<h3>Content Model</h3>
      <p>Optional repeatable choice of:</p>
<ul>
        <h2 id="element-type-label">Element Type: label</h2>
            <p>corresponds to rdfs:label</p>
          <h3>Content Model</h3>
<p>Simple type <a href="#simple-type-literal">literal</a></p>
        <h2 id="element-type-source">Element Type: source</h2>
            <p>if this node is from an ontology, the id of the ontology
if the node is from a dataset, the id/name of the dataset</p>
          <h3>Content Model</h3>
<p>Simple type <a href="#simple-type-linkref">linkref</a></p>
        <li>Exactly 1 <a href="#element-type-compositionalDescription">compositionalDescription</a>
</li>
        <li>Exactly 1 <a href="#group-Statement">Statement</a> group</li>
      </ul>
      
      
      
      
      
    
  <h2 id="element-type-compositionalDescription">Element Type: compositionalDescription</h2>
<h3>Content Model</h3>
<p>Simple type <a href="#simple-type-linkref">linkref</a></p>
  <h2 id="element-type-CompositionalDescription">Element Type: CompositionalDescription</h2>
      <p>same as a Descriptin in owl :
aka Logical Definition, cross-product, class expression.
A recursive construct for composing descriptions of entities using
logical connectives, classes and relations.
Note that this is purely a convenience class: a CompositionalDescription is 
semantically equivalent to a collection of link statements with intersection or union
semantics

Example:
The SO class SO:0000634 polycistronic_mRNA is composed from SO:0000234 "mRNA" and
SO:0000880 "polycistonic".
This is written in OWL syntax as:
Intersection( SO:0000234 restriction(has_quality someValuesFrom( SO:0000880 )  ))
The OBDXML looks like this:

&lt;CompositionalDescription predicate="INTERSECTION"&gt;
&lt;CompositionalDescription predicate="RESTRICTION"&gt;
  &lt;restriction&gt;
   &lt;LinkStatement appliesToAllInstancesOf="true" hasIntersectionSemantics="true"&gt;
   &lt;node about="SO:0000634"/&gt;
   &lt;relation about="has_quality"/&gt;
   &lt;target about="SO:0000880"/&gt;
   &lt;source about="sequence"/&gt;
   &lt;/LinkStatement&gt;
 &lt;/restriction&gt;
   &lt;Atom&gt;
SO:0000880  &lt;/Atom&gt;
&lt;/CompositionalDescription&gt;
 &lt;Atom&gt;
SO:0000234 &lt;/Atom&gt;
&lt;/CompositionalDescription&gt;
&lt;/pre&gt;</p>
    <table border="1">
<caption>Attributes</caption>
<tr valign="baseline">
<th align="left" rowspan="2">about</th>
<td>Simple type <a href="#simple-type-identifier_Type">identifier_Type</a>
</td>
<td>optional</td>
</tr>
<tr valign="baseline"><td colspan="2"></td></tr>
<tr valign="baseline">
<th align="left" rowspan="2">predicate</th>
<td>
          <p>Built-in type token</p>
<p>Enumeration:</p>
<ul>
<li><code>INTERSECTION</code></li>
<li><code>UNION</code></li>
<li><code>COMPLEMENT</code></li>
<li><code>RESTRICTION</code></li>
<li><code>ATOM</code></li>
</ul>
        </td>
<td>required</td>
</tr>
<tr valign="baseline"><td colspan="2"></td></tr>
</table>
<h3>Content Model</h3>
      <p>Optional repeatable choice of:</p>
<ul>
        <h2 id="element-type-label">Element Type: label</h2>
<h3>Content Model</h3>
<p>Simple type <a href="#simple-type-literal">literal</a></p>
        <li>Exactly 1 <a href="#element-type-restriction">restriction</a>
</li>
        <li>Exactly 1 <a href="#element-type-CompositionalDescription">CompositionalDescription</a>
</li>
      </ul>
      
      
    
  <h2 id="element-type-restriction">Element Type: restriction</h2>
      <p>only valid if this is of predicate RESTRICTION; points to a statement that must
be true of this description</p>
    <h3>Content Model</h3>
      <ul><li>Exactly 1 <a href="#group-Statement">Statement</a> group</li></ul>
    
  
    
      <p>Built-in type anyType</p>
    
  
  
    <p>Built-in type string</p>
  
  
    <p>Built-in type string</p>
  
</body>
</html>
